# Linux Interrupt, Exception and System Call

## Basic Knowledge

An interrupt is uaually defined as an *event* that alters the sequence of instructions executed by a processor.

* Synchronous interrupts ([exceptions](#Exception)): (同步中斷、異常)
  * produced by the *CPU control unit while executing instructions*
  * are called synchronous because the control unit issues them only after terminating the execution of an instruction
  * caused by
    * *interval timers* and *I/O* devices
* Asynchronous interrupts ([interrupts](#Interrupt)): (狹義的中斷)
  * generated by *other hardware devices at arbitrary times* with respect to the CPU clock signals
  * issued by
    * programming errors
    * ...

### Interrupt

Classify by where the interrupt come from

* Maskable interrupts
  * e.g. I/O device
* Nonmaskable interrupts ([NMI](https://en.wikipedia.org/wiki/Non-maskable_interrupt))
  * critical events (such as *hardware failure*)

### Exception

* Processor-detected executions
  * **Faults**: will resuming the instruction that caused the fault (return to original instruction, execute again)
    * e.g. page fault
  * **Traps**: the instruction that should be executed after one that caused the trap (return to next instruction)
    * e.g. debugging purpose
  * **Aborts**: force the affected process to terminate (return to anywhere else)
* Programmed exception (software interrupt)

### X86 Interrupt

* Hardware Interrupt Controllers [PIC (programmable interrupt controllers)](https://en.wikipedia.org/wiki/Programmable_interrupt_controller)
  * [Intel 8259](https://en.wikipedia.org/wiki/Intel_8259)
    * [Intel 8259A Manual](https://pdos.csail.mit.edu/6.828/2009/readings/hardware/8259A.pdf)
  * [APIC](https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller)
* Hardware Interrupt Handler

#### Hardware Interrupt Controllers

* Before Intel x86 (386), CPU use double interrupt controller 8259A, this can handle 15 external interrupt (each can handle 8, but need 1 to combine)
    > [Interrupt request (PC architecture)](https://en.wikipedia.org/wiki/Interrupt_request_(PC_architecture))
    >
    > * Master PIC
    >   * IRQ 0 – system timer (cannot be changed)
    >   * IRQ 1 – keyboard controller (cannot be changed)
    >   * IRQ 2 – cascaded signals from IRQs 8–15 (any devices configured to use IRQ 2 will actually be using IRQ 9)
    >   * IRQ 3 – serial port controller for serial port 2 (shared with serial port 4, if present)
    >   * IRQ 4 – serial port controller for serial port 1 (shared with serial port 3, if present)
    >   * IRQ 5 – parallel port 2 and 3  or  sound card
    >   * IRQ 6 – floppy disk controller
    >   * IRQ 7 – parallel port 1. It is used for printers or for any parallel port if a printer is not present. It can also be potentially be shared with a secondary sound card with careful management of the port.
    > * Slave PIC
    >   * IRQ 8 – real-time clock (RTC)
    >   * IRQ 9 – Advanced Configuration and Power Interface (ACPI) system control interrupt on Intel chipsets.[1] Other chipset manufacturers might use another interrupt for this purpose, or make it available for the use of peripherals (any devices configured to use IRQ 2 will actually be using IRQ 9)
    >   * IRQ 10 – The Interrupt is left open for the use of peripherals (open interrupt/available, SCSI or NIC)
    >   * IRQ 11 – The Interrupt is left open for the use of peripherals (open interrupt/available, SCSI or NIC)
    >   * IRQ 12 – mouse on PS/2 connector
    >   * IRQ 13 – CPU co-processor  or  integrated floating point unit  or  inter-processor interrupt (use depends on OS)
    >   * IRQ 14 – primary ATA channel (ATA interface usually serves hard disk drives and CD drives)
    >   * IRQ 15 – secondary ATA channel
* After Intel pentium, Intel use APIC (advanced programmable interrupt controllers) for better SMP support

#### Hardware Interrupt Handler

IRQ (Interrupt ReQuest, Interrupt Request Line)

Interrupt Controller numbering IRQ Lines start from 0

IRQ can be allocate to 32~238 (0x20~0xEE) except the 128 (this is used by *system call*)

```sh
$ cat /proc/interrupts
# or
$ procinfo
# on Windows use msinfo32.exe
```

* IRQ number
* The number of interrupts signaled since system boots
* The name of interrupt controller
* The name of interrupt handler

#### PIC Interrupt Handline

> The **Interrupt request** (中斷請求) is mapped to the **Interrupt Request Line** number (中斷請求線號) and the **Interrupt Vector** number (中斷向量號)

* IRR: Interrupt Request Register
* ISR: In-Service Register
* IMR: Interrupt Mask Register
* ICW: Initialization Command Word
* OCW: Operation Command Word

1. I/O dev assert IRQ and pin
2. PIC set IRR bit and send INT signal to CPU
3. CPU ack the INT signal by sending INTA to PIC
4. PIC then set ISR bit and clear IRR bit
5. PIC initialize a second INTA to tell CPU the vector number
6. CPU get vector num, start the ISR
7. At the end of ISR, ISR issue EOI
8. Upon receiving EOI, PIC clear the ISR bit and start to accept another interrupt

![IRQ # to Int #](https://superchargedcomputing.files.wordpress.com/2018/02/pic_hardware_interrupt_path2.png?w=840)

## Linux Interrupt Handling

### Interrupt Handling Sequence

* If interrupt is NMI, SMI, INIT, ExtINT => send directly to processor coure to handline
* Otherwise => accept interrupt: set **IRR/ISR** to indicate pending interrupt

### Interrupt Vector

Each interrupt or exception is identified by a number ranging from 0~255 (8-bit unsigned number)

* The vectors of *nonmaskable interrupts* and *exceptions* are fixed
* The vectors of *maskable interrupts* can be *altered by programming the **Interrupt Controller***

### Interrupt Descriptor

> [Interrupt Descriptor Table (IDT)](https://en.wikipedia.org/wiki/Interrupt_descriptor_table) 中斷描述符表 is a data structure used by the x86 architecture to implement an interrupt vector table.
>
> The IDT is used by the processor to determine the correct response to interrupts and exceptions.
>
> Interrupt Descriptor contain the address of Interrupt Handler.

* In Real Mode (實地址模式)
* In Protected Mode (保護模式)
  * Gate Descriptor 門描述符 (GDT)
  * IDTR: store both the physical base address and the length in bytes of the IDT

#### Interrupt Descriptor in Linux

* Interrupt Gate
* Trap Gate
* Task Gate
* System Gate
* System Interrupt Gate

### Linux Code

1. `setup_idt()`
2. `start_kernel()` - [`/init/main.c`](https://github.com/torvalds/linux/blob/master/init/main.c#L545)
   1. `setup_arch()` - [`/arch/x86/kernel/setup.c`](https://github.com/torvalds/linux/blob/master/arch/x86/kernel/setup.c#L873)
      * `early_trap_init()` (32-bit) set page fault exception entrance
      * `early_trap_pf_init` (64-bit) set page fault exception entrance
   2. `trap_init()`
   3. `early_irq_init()`
   4. `init_IRQ()` - [`arch/x86/kernel/irqinit.c`](https://github.com/torvalds/linux/blob/master/arch/x86/kernel/irqinit.c#L79)
   5. `softirq_init()`
   6. `local_irq_enable()`

`arch/x86/include/asm/x86_init.h`

#### Exception Handling

* [`do_trap()`](https://github.com/torvalds/linux/blob/master/arch/s390/kernel/traps.c#L66)

> In 64-bit, Linux use the **zeroentry macro** to implement ([the commit on `entry_64.S`](https://github.com/torvalds/linux/commit/d99015b1abbad743aa049b439c1e1dede6d0fa49))

[`include/linux/extable.h`](https://github.com/torvalds/linux/blob/master/include/linux/extable.h)

#### Interrupt Handling

[`x86_init()`](https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/x86_init.h#L295) -> [`struct x86_init_ops`](https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/x86_init.h#L149) (`struct x86_init_irqs irqs;`) -> [`struct x86_init_irqs`](https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/x86_init.h#L56)

> Many IRQ is undefined => it is requested dynamically. The common interrupt.

[`entry_64.S`](https://github.com/torvalds/linux/blob/master/arch/x86/entry/entry_64.S)

* [`common_interrupt`](https://github.com/torvalds/linux/blob/master/arch/x86/entry/entry_64.S#L579)
  * call [`do_IRQ`](https://github.com/torvalds/linux/blob/master/arch/x86/kernel/irq.c#L232)
    * [`ack_APIC_irq`](https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/apic.h#L442)

#### Interrupt and Exception Handling Procedure

* [Notes on CPL, DPL and RPL terms](https://iambvk.wordpress.com/2007/10/10/notes-on-cpl-dpl-and-rpl-terms/)
  * CPL – Current Privilege Level
  * DPL – Descriptor Privilege Level
  * RPL – Requested Privilege Level

[`handle_irq_event()`](https://github.com/torvalds/linux/blob/master/kernel/irq/handle.c#L198)

[`irq_desc[NR_IRQS]`](https://github.com/torvalds/linux/blob/master/include/linux/irqdesc.h#L117) - [`include/linux/irqdesc.h`](https://github.com/torvalds/linux/blob/master/include/linux/irqdesc.h#L56)
Used to be an array. Now using Radix Tree (基數樹)

#### Mapping between Interrupt Vector and IRQ Number

IRQ Number ==> [`irq_domain`](https://github.com/torvalds/linux/blob/master/include/linux/irqdomain.h#L159) -> corresponds to Interrupt Controller resources ==> Interrupt Vector

[`irq_domain_alloc_irqs()`](https://github.com/torvalds/linux/blob/master/include/linux/irqdomain.h#L465)

[`irq_to_desc`](https://github.com/torvalds/linux/blob/master/kernel/irq/irqdesc.c#L337)

```c
/*
 * irq_domain - IRQ translation domains
 *
 * Translation infrastructure between hw and linux irq numbers.  This is
 * helpful for interrupt controllers to implement mapping between hardware
 * irq numbers and the Linux irq number space.
 */
```

1. [Linear Map](https://github.com/torvalds/linux/blob/master/include/linux/irqdomain.h#L184)
2. [Radix Tree Map](https://github.com/torvalds/linux/blob/master/include/linux/irqdomain.h#L182)

#### Interrupt Handling Data Structure

[#ifdef CONFIG_SPARSE_IRQ](https://github.com/torvalds/linux/blob/master/kernel/irq/irqdesc.c#L136)

[irqaction](https://github.com/torvalds/linux/blob/master/include/linux/interrupt.h#L110)

#### Interrupt Handler

ISR (Interrupt Service Routine) (don't be confused with In-service Register)

IRQ Stack

[`irq_ctx`](https://github.com/torvalds/linux/blob/master/arch/sh/kernel/irq.c#L60)

```c
#ifdef CONFIG_IRQSTACKS
/*
 * per-CPU IRQ handling contexts (thread information and stack)
 */
union irq_ctx {
	struct thread_info	tinfo;
	u32			stack[THREAD_SIZE/sizeof(u32)];
};

static union irq_ctx *hardirq_ctx[NR_CPUS] __read_mostly;
static union irq_ctx *softirq_ctx[NR_CPUS] __read_mostly;

static char softirq_stack[NR_CPUS * THREAD_SIZE] __page_aligned_bss;
static char hardirq_stack[NR_CPUS * THREAD_SIZE] __page_aligned_bss;
```

### Interrupt Context

kernel control path

ISR

TBD

* Top Half
  * Key Operation
  * TBD
* Buttom Half
  * TBD

`in_interrupt`

[`kernel/irq/manage.c`](https://github.com/torvalds/linux/blob/master/kernel/irq/manage.c)

`request_irq()`

[`free_irq()`](https://github.com/torvalds/linux/blob/master/kernel/irq/manage.c#L1814)

`irqreturn_t handler`

`request_irq()` with IRQF_SHARED flag

## Bottom Half

## Application

## Resources

* [Supercharged Computing Notes - Interrupts, Signals and Exceptions](https://superchargedcomputing.com/2018/02/07/interrupts-and-exceptions/)
